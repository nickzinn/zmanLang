// Comprehensive ZManLang v0 compiler regression test
// Exercises: globals (let/const), arithmetic + precedence, comparisons, if/else,
// while loops, short-circuit and/or, unary ! / not, strings + concatenation,
// length() on string/array, arrays (alloc/index/store), foreach (in function),
// recursion, and number(text(x)) roundtrip.

println("kitchen_sink");

const c := 7;
println("c=" + text(c));

let x := 1 + 2 * 3;
println("expr=" + text(x));

let y := (1 + 2) * 3;
println("expr2=" + text(y));

let neg := -5;
println("neg=" + text(neg));

println("divmod=" + text(17 / 5) + "," + text(17 % 5));

if (1 < 2 and 0 < 1) {
  println("and1");
} else {
  println("bad");
}

// Short-circuit tests: RHS would trap if evaluated.
if (0 and (1 / 0 = 0)) {
  println("bad");
} else {
  println("sc_and_ok");
}

if (1 or (1 / 0 = 0)) {
  println("sc_or_ok");
} else {
  println("bad");
}

if (!0) {
  println("not_ok");
} else {
  println("bad");
}

let s1 := "hi";
let s2 := "there";
let s3 := s1 + " " + s2 + "!";
println(s3);
println("slen=" + text(length(s3)));

let a := [5];
let i := 0;
while (i < length(a)) {
  a[i] := i * i;
  i := i + 1;
}

println("alen=" + text(length(a)));
println(text(a[0]) + "," + text(a[1]) + "," + text(a[2]) + "," + text(a[3]) + "," + text(a[4]));

let b := a;
let a2 := [5];
print("aid=");
if (a = b) {
  print("1");
} else {
  print("0");
}
print(",");
if (a = a2) {
  print("1");
} else {
  print("0");
}
println("");

func sum(arr[]) {
  let s := 0;
  foreach(v, arr) {
    s := s + v;
  }
  return s;
}

func cloneArray(src[]) {
  let n := length(src);
  let dst := [n];
  let i := 0;
  while (i < n) {
    dst[i] := src[i];
    i := i + 1;
  }
  return dst;
}

func swap(arr[], i, j) {
  let tmp := arr[i];
  arr[i] := arr[j];
  arr[j] := tmp;
  return 0;
}

// Classic CS algorithm test: in-place bubble sort on int arrays.
func bubbleSort(arr[]) {
  let n := length(arr);
  let i := 0;
  while (i < n) {
    let j := 0;
    while (j < n - 1) {
      if (arr[j] > arr[j + 1]) {
        swap(arr, j, j + 1);
      }
      j := j + 1;
    }
    i := i + 1;
  }
  return 0;
}

// Insertion sort (stable, in-place)
func insertionSort(arr[]) {
  let n := length(arr);
  let i := 1;
  while (i < n) {
    let key := arr[i];
    let j := i - 1;
    while (j >= 0 and arr[j] > key) {
      arr[j + 1] := arr[j];
      j := j - 1;
    }
    arr[j + 1] := key;
    i := i + 1;
  }
  return 0;
}

func partition(arr[], lo, hi) {
  let pivot := arr[hi];
  let i := lo - 1;
  let j := lo;
  while (j < hi) {
    if (arr[j] <= pivot) {
      i := i + 1;
      swap(arr, i, j);
    }
    j := j + 1;
  }
  swap(arr, i + 1, hi);
  return i + 1;
}

// Quick sort (in-place, recursive)
func quickSortRange(arr[], lo, hi) {
  if (lo < hi) {
    let p := partition(arr, lo, hi);
    quickSortRange(arr, lo, p - 1);
    quickSortRange(arr, p + 1, hi);
  }
  return 0;
}

func quickSort(arr[]) {
  let n := length(arr);
  if (n > 0) {
    quickSortRange(arr, 0, n - 1);
  }
  return 0;
}

func isSorted(arr[]) {
  let n := length(arr);
  let i := 1;
  let ok := 1;
  while (i < n) {
    if (arr[i - 1] > arr[i]) {
      ok := 0;
    }
    i := i + 1;
  }
  return ok;
}

// Classic search algorithms
func linearSearch(arr[], key) {
  let n := length(arr);
  let i := 0;
  while (i < n) {
    if (arr[i] = key) {
      return i;
    }
    i := i + 1;
  }
  return -1;
}

// Returns index of key in sorted arr, or -1 if not found.
func binarySearch(arr[], key) {
  let lo := 0;
  let hi := length(arr) - 1;
  while (lo <= hi) {
    let mid := (lo + hi) / 2;
    let v := arr[mid];
    if (v = key) {
      return mid;
    } else {
      if (v < key) {
        lo := mid + 1;
      } else {
        hi := mid - 1;
      }
    }
  }
  return -1;
}

println("sumsq=" + text(sum(a)));

let d := {5,1,4,2,8,0,-3,9,7,6,12,-1,3,10,11,-2};

print("sort_input=");
print(d);
println("");

let db := cloneArray(d);
bubbleSort(db);
print("bubble=");
println(db);
print("bubble_sorted=");
if (isSorted(db)) { println("1"); } else { println("0"); }

let di := cloneArray(d);
insertionSort(di);
print("insertion=");
println(di);
print("insertion_sorted=");
if (isSorted(di)) { println("1"); } else { println("0"); }

let dq := cloneArray(d);
quickSort(dq);
print("quick=");
println(dq);
print("quick_sorted=");
if (isSorted(dq)) { println("1"); } else { println("0"); }

// Search on sorted array (dq)
println("search_lin_-2=" + text(linearSearch(dq, -2)));
println("search_bin_-2=" + text(binarySearch(dq, -2)));
println("search_lin_42=" + text(linearSearch(dq, 42)));
println("search_bin_42=" + text(binarySearch(dq, 42)));

func fact(n) {
  if (n = 0) {
    return 1;
  } else {
    return n * fact(n - 1);
  }
}

println("fact6=" + text(fact(6)));

let round := number(text(-12345));
println("round=" + text(round));

let e := "x\n";
println("elen=" + text(length(e)));
